[{"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\index.tsx":"1","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\serviceWorker.js":"2","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\app.tsx":"3","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\client.tsx":"4","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\index.ts":"5","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\media\\index.tsx":"6","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\Home.tsx":"7","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\media\\SearchMedia.tsx":"8","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\Anime\\index.tsx":"9","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\types\\graphql.ts":"10","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\ui\\useDropdown.tsx":"11","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\Anime\\Edit.tsx":"12","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\ui\\Spinner.tsx":"13","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\anime\\AnimeEdit.tsx":"14","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\globalStyles.tsx":"15","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\GlobalStyles.tsx":"16","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\searchMedia\\SearchMediaLayout.tsx":"17","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\components\\button.tsx":"18","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\components\\input.tsx":"19","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\components\\select.tsx":"20"},{"size":340,"mtime":1610373456400,"results":"21","hashOfConfig":"22"},{"size":4293,"mtime":1609789698680,"results":"23","hashOfConfig":"22"},{"size":1694,"mtime":1610377600855,"results":"24","hashOfConfig":"22"},{"size":434,"mtime":1609789698679,"results":"25","hashOfConfig":"22"},{"size":81,"mtime":1609878781464,"results":"26","hashOfConfig":"22"},{"size":208,"mtime":1610312837329,"results":"27","hashOfConfig":"22"},{"size":910,"mtime":1610362154418,"results":"28","hashOfConfig":"22"},{"size":2387,"mtime":1610377426679,"results":"29","hashOfConfig":"22"},{"size":535,"mtime":1610319887075,"results":"30","hashOfConfig":"22"},{"size":100950,"mtime":1610312837362,"results":"31","hashOfConfig":"22"},{"size":1096,"mtime":1610371076386,"results":"32","hashOfConfig":"22"},{"size":1030,"mtime":1610319887061,"results":"33","hashOfConfig":"22"},{"size":422,"mtime":1609878781383,"results":"34","hashOfConfig":"22"},{"size":2130,"mtime":1610319887017,"results":"35","hashOfConfig":"22"},{"size":1838,"mtime":1610376586558,"results":"36","hashOfConfig":"22"},{"size":1796,"mtime":1610379777764,"results":"37","hashOfConfig":"22"},{"size":3414,"mtime":1610379863585,"results":"38","hashOfConfig":"22"},{"size":460,"mtime":1610378327981,"results":"39","hashOfConfig":"22"},{"size":218,"mtime":1610370073559,"results":"40","hashOfConfig":"22"},{"size":271,"mtime":1610377143975,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"167w7bo",{"filePath":"45","messages":"46","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"44"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"62","messages":"63","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"44"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"44"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"44"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"44"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"80"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\index.tsx",[],["91","92"],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\serviceWorker.js",["93","94","95"],"const isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service worker.'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n",["96","97"],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\app.tsx",["98","99","100","101","102"],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\client.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\index.ts",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\media\\index.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\Home.tsx",["103","104"],"import React, { ReactElement, useState } from 'react';\nimport { Link } from 'react-router-dom';\n\nconst Home = (): ReactElement => {\n  const [addDropdownOpen, setAddDropdownOpen] = useState(false);\n  const [editDropdownOpen, setEditDropdownOpen] = useState(false);\n\n  return (\n    <div>\n      <div>\n        <h1>What would you like to do?</h1>\n        <p>Select an action below to get started.</p>\n        <hr />\n        <div>\n          <div className={`dropdown-menu${addDropdownOpen ? ' show' : ''}`}>\n            <Link to=\"/anime/add\" className=\"dropdown-item\">\n              Anime\n            </Link>\n          </div>\n        </div>\n        <div>\n          <div className={`dropdown-menu${editDropdownOpen ? ' show' : ''}`}>\n            <Link to=\"/media\" className=\"dropdown-item\">\n              Media\n            </Link>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Home;\n","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\media\\SearchMedia.tsx",["105","106"],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\Anime\\index.tsx",["107","108"],"import React, { ReactElement } from 'react';\nimport { Route, Switch } from 'react-router-dom';\nimport Edit from './Edit';\n\nconst Anime = ({\n  match,\n  location,\n}: {\n  match: any;\n  location: any;\n}): ReactElement => (\n  <>\n    <Switch>\n      <Route\n        path={`${match.path}/:id`}\n        render={({ match }) => <Edit id={match.params.id} />}\n      />\n      {/* <Route\n        path={`${match.path}/:slug`}\n        render={({ match }) => <Edit slug={match.params.slug} />}\n      /> */}\n    </Switch>\n  </>\n);\n\nexport default Anime;\n","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\types\\graphql.ts",["109","110","111","112","113"],"export type Maybe<T> = T | null;\nexport type Exact<T extends { [key: string]: unknown }> = {\n  [K in keyof T]: T[K];\n};\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> &\n  { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> &\n  { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** A date, expressed as an ISO8601 string */\n  Date: any;\n  /** An ISO 8601-encoded date */\n  ISO8601Date: any;\n  /** An ISO 8601-encoded datetime */\n  ISO8601DateTime: any;\n  /** A loose key-value map in GraphQL */\n  Map: any;\n  Upload: any;\n};\n\n/** A user account on Kitsu */\nexport type Account = WithTimestamps & {\n  readonly __typename?: 'Account';\n  /** The country this user resides in */\n  readonly country?: Maybe<Scalars['String']>;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** The email addresses associated with this account */\n  readonly email: ReadonlyArray<Scalars['String']>;\n  /** Facebook account linked to the account */\n  readonly facebookId?: Maybe<Scalars['String']>;\n  readonly id: Scalars['ID'];\n  /** Primary language for the account */\n  readonly language?: Maybe<Scalars['String']>;\n  /** Longest period an account has had a PRO subscription for in seconds */\n  readonly maxProStreak?: Maybe<Scalars['Int']>;\n  /** The PRO subscription for this account */\n  readonly proSubscription?: Maybe<ProSubscription>;\n  /** The profile for this account */\n  readonly profile: Profile;\n  /** Media rating system used for the account */\n  readonly ratingSystem: RatingSystemEnum;\n  /** Whether Not Safe For Work content is accessible */\n  readonly sfwFilter?: Maybe<Scalars['Boolean']>;\n  /** The site-wide permissions this user has access to */\n  readonly sitePermissions: ReadonlyArray<SitePermissionEnum>;\n  /** Time zone of the account */\n  readonly timeZone?: Maybe<Scalars['String']>;\n  /** Preferred language for media titles */\n  readonly titleLanguagePreference?: Maybe<TitleLanguagePreferenceEnum>;\n  /** Twitter account linked to the account */\n  readonly twitterId?: Maybe<Scalars['String']>;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\nexport enum AgeRatingEnum {\n  /** Acceptable for all ages */\n  G = 'G',\n  /** Parental guidance suggested; should be safe for preteens and older */\n  Pg = 'PG',\n  /** Possible lewd or intense themes; should be safe for teens and older */\n  R = 'R',\n  /** Contains adult content or themes; should only be viewed by adults */\n  R18 = 'R18',\n}\n\n/** Generic Amount Consumed based on Media */\nexport type AmountConsumed = {\n  /** Total media completed atleast once. */\n  readonly completed: Scalars['Int'];\n  readonly id: Scalars['ID'];\n  /** Total amount of media. */\n  readonly media: Scalars['Int'];\n  /** The profile related to the user for this stat. */\n  readonly profile: Profile;\n  /** Last time we fully recalculated this stat. */\n  readonly recalculatedAt: Scalars['ISO8601Date'];\n  /** Total progress of library including reconsuming. */\n  readonly units: Scalars['Int'];\n};\n\nexport type Anime = Media &\n  Episodic &\n  WithTimestamps & {\n    readonly __typename?: 'Anime';\n    /** The recommended minimum age group for this media */\n    readonly ageRating?: Maybe<AgeRatingEnum>;\n    /** An explanation of why this received the age rating it did */\n    readonly ageRatingGuide?: Maybe<Scalars['String']>;\n    /** The average rating of this media amongst all Kitsu users */\n    readonly averageRating?: Maybe<Scalars['Float']>;\n    /** A large banner image for this media */\n    readonly bannerImage: Image;\n    /** A list of categories for this media */\n    readonly categories: CategoryConnection;\n    /** The characters who starred in this media */\n    readonly characters: MediaCharacterConnection;\n    readonly createdAt: Scalars['ISO8601DateTime'];\n    /** A brief (mostly spoiler free) summary or description of the media. */\n    readonly description: Scalars['Map'];\n    /** the day that this media made its final release */\n    readonly endDate?: Maybe<Scalars['Date']>;\n    /** The number of episodes in this series */\n    readonly episodeCount?: Maybe<Scalars['Int']>;\n    /** The general length (in seconds) of each episode */\n    readonly episodeLength?: Maybe<Scalars['Int']>;\n    /** Episodes for this media */\n    readonly episodes: EpisodeConnection;\n    /** The number of users with this in their favorites */\n    readonly favoritesCount?: Maybe<Scalars['Int']>;\n    readonly id: Scalars['ID'];\n    /** A list of mappings for this media */\n    readonly mappings: MappingConnection;\n    /** The time of the next release of this media */\n    readonly nextRelease?: Maybe<Scalars['ISO8601DateTime']>;\n    /** The poster image of this media */\n    readonly posterImage: Image;\n    /** The companies which helped to produce this media */\n    readonly productions: MediaProductionConnection;\n    /** A list of quotes from this media */\n    readonly quotes: QuoteConnection;\n    /** A list of reactions for this media */\n    readonly reactions: MediaReactionConnection;\n    /** The season this was released in */\n    readonly season?: Maybe<ReleaseSeasonEnum>;\n    /** Whether the media is Safe-for-Work */\n    readonly sfw: Scalars['Boolean'];\n    /** The URL-friendly identifier of this media */\n    readonly slug: Scalars['String'];\n    /** The staff members who worked on this media */\n    readonly staff: MediaStaffConnection;\n    /** The day that this media first released */\n    readonly startDate?: Maybe<Scalars['Date']>;\n    /** The current releasing status of this media */\n    readonly status: ReleaseStatusEnum;\n    /** The stream links. */\n    readonly streamingLinks: StreamingLinkConnection;\n    /** A secondary type for categorizing Anime. */\n    readonly subtype: AnimeSubtypeEnum;\n    /** Description of when this media is expected to release */\n    readonly tba?: Maybe<Scalars['String']>;\n    /** The titles for this media in various locales */\n    readonly titles: TitlesList;\n    /** The total length (in seconds) of the entire series */\n    readonly totalLength?: Maybe<Scalars['Int']>;\n    /** Anime or Manga. */\n    readonly type: Scalars['String'];\n    readonly updatedAt: Scalars['ISO8601DateTime'];\n    /** The number of users with this in their library */\n    readonly userCount?: Maybe<Scalars['Int']>;\n    /** Video id for a trailer on YouTube */\n    readonly youtubeTrailerVideoId?: Maybe<Scalars['String']>;\n  };\n\nexport type AnimeCategoriesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeCharactersArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\nexport type AnimeEpisodesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  number?: Maybe<ReadonlyArray<Scalars['Int']>>;\n};\n\nexport type AnimeMappingsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeProductionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeQuotesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeReactionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeStaffArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeStreamingLinksArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type AnimeAmountConsumed = AmountConsumed & {\n  readonly __typename?: 'AnimeAmountConsumed';\n  /** Total media completed atleast once. */\n  readonly completed: Scalars['Int'];\n  readonly id: Scalars['ID'];\n  /** Total amount of media. */\n  readonly media: Scalars['Int'];\n  /** The profile related to the user for this stat. */\n  readonly profile: Profile;\n  /** Last time we fully recalculated this stat. */\n  readonly recalculatedAt: Scalars['ISO8601Date'];\n  /** Total time spent in minutes. */\n  readonly time: Scalars['Int'];\n  /** Total progress of library including reconsuming. */\n  readonly units: Scalars['Int'];\n};\n\nexport type AnimeCategoryBreakdown = CategoryBreakdown & {\n  readonly __typename?: 'AnimeCategoryBreakdown';\n  /** A Map of category_id -> count for all categories present on the library entries */\n  readonly categories: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** The profile related to the user for this stat. */\n  readonly profile: Profile;\n  /** Last time we fully recalculated this stat. */\n  readonly recalculatedAt: Scalars['ISO8601Date'];\n  /** The total amount of library entries. */\n  readonly total: Scalars['Int'];\n};\n\n/** The connection type for Anime. */\nexport type AnimeConnection = {\n  readonly __typename?: 'AnimeConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<AnimeEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Anime>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\nexport type AnimeCreateInput = {\n  readonly titles: TitlesListInput;\n  readonly description: Scalars['Map'];\n  readonly ageRating?: Maybe<AgeRatingEnum>;\n  readonly ageRatingGuide?: Maybe<Scalars['String']>;\n  readonly tba?: Maybe<Scalars['String']>;\n  readonly startDate?: Maybe<Scalars['Date']>;\n  readonly endDate?: Maybe<Scalars['Date']>;\n  readonly posterImage?: Maybe<Scalars['Upload']>;\n  readonly bannerImage?: Maybe<Scalars['Upload']>;\n  readonly youtubeTrailerVideoId?: Maybe<Scalars['String']>;\n  readonly episodeCount?: Maybe<Scalars['Int']>;\n  readonly episodeLength?: Maybe<Scalars['Int']>;\n};\n\n/** Autogenerated return type of AnimeCreate */\nexport type AnimeCreatePayload = {\n  readonly __typename?: 'AnimeCreatePayload';\n  readonly anime?: Maybe<Anime>;\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** Autogenerated return type of AnimeDelete */\nexport type AnimeDeletePayload = {\n  readonly __typename?: 'AnimeDeletePayload';\n  readonly anime?: Maybe<GenericDelete>;\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** An edge in a connection. */\nexport type AnimeEdge = {\n  readonly __typename?: 'AnimeEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Anime>;\n};\n\nexport type AnimeMutation = {\n  readonly __typename?: 'AnimeMutation';\n  /** Create an Anime. */\n  readonly create?: Maybe<AnimeCreatePayload>;\n  /** Delete an Anime. */\n  readonly delete?: Maybe<AnimeDeletePayload>;\n  /** Update an Anime. */\n  readonly update?: Maybe<AnimeUpdatePayload>;\n};\n\nexport type AnimeMutationCreateArgs = {\n  input: AnimeCreateInput;\n};\n\nexport type AnimeMutationDeleteArgs = {\n  input: GenericDeleteInput;\n};\n\nexport type AnimeMutationUpdateArgs = {\n  input: AnimeUpdateInput;\n};\n\nexport enum AnimeSubtypeEnum {\n  Tv = 'TV',\n  /** Spinoffs or Extras of the original. */\n  Special = 'SPECIAL',\n  /** Original Video Animation. Anime directly released to video market. */\n  Ova = 'OVA',\n  /** Original Net Animation (Web Anime). */\n  Ona = 'ONA',\n  Movie = 'MOVIE',\n  Music = 'MUSIC',\n}\n\nexport type AnimeUpdateInput = {\n  readonly id: Scalars['ID'];\n  readonly titles?: Maybe<TitlesListInput>;\n  readonly description?: Maybe<Scalars['Map']>;\n  readonly ageRating?: Maybe<AgeRatingEnum>;\n  readonly ageRatingGuide?: Maybe<Scalars['String']>;\n  readonly tba?: Maybe<Scalars['String']>;\n  readonly startDate?: Maybe<Scalars['Date']>;\n  readonly endDate?: Maybe<Scalars['Date']>;\n  readonly posterImage?: Maybe<Scalars['Upload']>;\n  readonly bannerImage?: Maybe<Scalars['Upload']>;\n  readonly youtubeTrailerVideoId?: Maybe<Scalars['String']>;\n  readonly episodeCount?: Maybe<Scalars['Int']>;\n  readonly episodeLength?: Maybe<Scalars['Int']>;\n};\n\n/** Autogenerated return type of AnimeUpdate */\nexport type AnimeUpdatePayload = {\n  readonly __typename?: 'AnimeUpdatePayload';\n  readonly anime?: Maybe<Anime>;\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** Generic error fields used by all errors. */\nexport type Base = {\n  /** The error code. */\n  readonly code?: Maybe<Scalars['String']>;\n  /** A description of the error */\n  readonly message: Scalars['String'];\n  /** Which input value this error came from */\n  readonly path?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** Information about a specific Category */\nexport type Category = WithTimestamps & {\n  readonly __typename?: 'Category';\n  /** The child categories. */\n  readonly children?: Maybe<CategoryConnection>;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** A brief summary or description of the catgory. */\n  readonly description: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** Whether the category is Not-Safe-for-Work. */\n  readonly isNsfw: Scalars['Boolean'];\n  /** The parent category. Each category can have one parent. */\n  readonly parent?: Maybe<Category>;\n  /** The URL-friendly identifier of this Category. */\n  readonly slug: Scalars['String'];\n  /** The name of the category. */\n  readonly title: Scalars['Map'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** Information about a specific Category */\nexport type CategoryChildrenArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** Information about a specific Category */\nexport type CategoryDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** Information about a specific Category */\nexport type CategoryTitleArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** Generic Category Breakdown based on Media */\nexport type CategoryBreakdown = {\n  /** A Map of category_id -> count for all categories present on the library entries */\n  readonly categories: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** The profile related to the user for this stat. */\n  readonly profile: Profile;\n  /** Last time we fully recalculated this stat. */\n  readonly recalculatedAt: Scalars['ISO8601Date'];\n  /** The total amount of library entries. */\n  readonly total: Scalars['Int'];\n};\n\n/** The connection type for Category. */\nexport type CategoryConnection = {\n  readonly __typename?: 'CategoryConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<CategoryEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Category>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CategoryEdge = {\n  readonly __typename?: 'CategoryEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Category>;\n};\n\n/** A single chapter of a manga */\nexport type Chapter = Unit &\n  WithTimestamps & {\n    readonly __typename?: 'Chapter';\n    readonly createdAt: Scalars['ISO8601DateTime'];\n    /** A brief summary or description of the unit */\n    readonly description: Scalars['Map'];\n    readonly id: Scalars['ID'];\n    /** The manga this chapter is in. */\n    readonly manga: Manga;\n    /** The sequence number of this unit */\n    readonly number: Scalars['Int'];\n    /** When this chapter was released */\n    readonly releasedAt?: Maybe<Scalars['ISO8601Date']>;\n    /** A thumbnail image for the unit */\n    readonly thumbnail?: Maybe<Image>;\n    /** The titles for this unit in various locales */\n    readonly titles: TitlesList;\n    readonly updatedAt: Scalars['ISO8601DateTime'];\n    /** The volume this chapter is in. */\n    readonly volume?: Maybe<Volume>;\n  };\n\n/** A single chapter of a manga */\nexport type ChapterDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** The connection type for Chapter. */\nexport type ChapterConnection = {\n  readonly __typename?: 'ChapterConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<ChapterEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Chapter>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ChapterEdge = {\n  readonly __typename?: 'ChapterEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Chapter>;\n};\n\n/** Information about a Character in the Kitsu database */\nexport type Character = WithTimestamps & {\n  readonly __typename?: 'Character';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** A brief summary or description of the character. */\n  readonly description: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** An image of the character */\n  readonly image?: Maybe<Image>;\n  /** Media this character appears in. */\n  readonly media?: Maybe<MediaCharacterConnection>;\n  /** The name for this character in various locales */\n  readonly names?: Maybe<TitlesList>;\n  /** The original media this character showed up in */\n  readonly primaryMedia?: Maybe<Media>;\n  /** The URL-friendly identifier of this character */\n  readonly slug: Scalars['String'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** Information about a Character in the Kitsu database */\nexport type CharacterDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** Information about a Character in the Kitsu database */\nexport type CharacterMediaArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport enum CharacterRoleEnum {\n  /** A character who appears throughout a series and is a focal point of the media */\n  Main = 'MAIN',\n  /** A character who appears in multiple episodes but is not a main character */\n  Recurring = 'RECURRING',\n  /** A background character who generally only appears in a few episodes */\n  Background = 'BACKGROUND',\n  /** A character from a different franchise making a (usually brief) appearance */\n  Cameo = 'CAMEO',\n}\n\n/** Information about a VA (Person) voicing a Character in a Media */\nexport type CharacterVoice = WithTimestamps & {\n  readonly __typename?: 'CharacterVoice';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The company who hired this voice actor to play this role */\n  readonly licensor?: Maybe<Producer>;\n  /** The BCP47 locale tag for the voice acting role */\n  readonly locale: Scalars['String'];\n  /** The MediaCharacter node */\n  readonly mediaCharacter: MediaCharacter;\n  /** The person who voice acted this role */\n  readonly person: Person;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** The connection type for CharacterVoice. */\nexport type CharacterVoiceConnection = {\n  readonly __typename?: 'CharacterVoiceConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<CharacterVoiceEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<CharacterVoice>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CharacterVoiceEdge = {\n  readonly __typename?: 'CharacterVoiceEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<CharacterVoice>;\n};\n\n/** A comment on a post */\nexport type Comment = WithTimestamps & {\n  readonly __typename?: 'Comment';\n  /** The user who created this comment for the parent post. */\n  readonly author: Profile;\n  /** Unmodified content. */\n  readonly content: Scalars['String'];\n  /** Html formatted content. */\n  readonly contentFormatted: Scalars['String'];\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** Users who liked this comment. */\n  readonly likes: ProfileConnection;\n  /** The parent comment if this comment was a reply to another. */\n  readonly parent?: Maybe<Comment>;\n  /** The post that this comment is attached to. */\n  readonly post: Post;\n  /** All replies to a specific comment. */\n  readonly replies: CommentConnection;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** A comment on a post */\nexport type CommentLikesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A comment on a post */\nexport type CommentRepliesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The connection type for Comment. */\nexport type CommentConnection = {\n  readonly __typename?: 'CommentConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<CommentEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Comment>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CommentEdge = {\n  readonly __typename?: 'CommentEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Comment>;\n};\n\n/** An Episode of a Media */\nexport type Episode = Unit &\n  WithTimestamps & {\n    readonly __typename?: 'Episode';\n    /** The anime this episode is in */\n    readonly anime: Anime;\n    readonly createdAt: Scalars['ISO8601DateTime'];\n    /** A brief summary or description of the unit */\n    readonly description: Scalars['Map'];\n    readonly id: Scalars['ID'];\n    /** The length of the episode in seconds */\n    readonly length?: Maybe<Scalars['Int']>;\n    /** The sequence number of this unit */\n    readonly number: Scalars['Int'];\n    /** When this episode aired */\n    readonly releasedAt?: Maybe<Scalars['ISO8601DateTime']>;\n    /** A thumbnail image for the unit */\n    readonly thumbnail?: Maybe<Image>;\n    /** The titles for this unit in various locales */\n    readonly titles: TitlesList;\n    readonly updatedAt: Scalars['ISO8601DateTime'];\n  };\n\n/** An Episode of a Media */\nexport type EpisodeDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** The connection type for Episode. */\nexport type EpisodeConnection = {\n  readonly __typename?: 'EpisodeConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<EpisodeEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Episode>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\nexport type EpisodeCreateInput = {\n  readonly mediaId: Scalars['ID'];\n  readonly mediaType: MediaTypeEnum;\n  readonly titles: TitlesListInput;\n  readonly number: Scalars['Int'];\n  readonly description?: Maybe<Scalars['Map']>;\n  readonly length?: Maybe<Scalars['Int']>;\n  readonly releasedAt?: Maybe<Scalars['Date']>;\n  readonly thumbnailImage?: Maybe<Scalars['Upload']>;\n};\n\n/** Autogenerated return type of EpisodeCreate */\nexport type EpisodeCreatePayload = {\n  readonly __typename?: 'EpisodeCreatePayload';\n  readonly episode?: Maybe<Episode>;\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** Autogenerated return type of EpisodeDelete */\nexport type EpisodeDeletePayload = {\n  readonly __typename?: 'EpisodeDeletePayload';\n  readonly episode?: Maybe<GenericDelete>;\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** An edge in a connection. */\nexport type EpisodeEdge = {\n  readonly __typename?: 'EpisodeEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Episode>;\n};\n\nexport type EpisodeMutation = {\n  readonly __typename?: 'EpisodeMutation';\n  /** Create an Episode. */\n  readonly create?: Maybe<EpisodeCreatePayload>;\n  /** Delete an Episode. */\n  readonly delete?: Maybe<EpisodeDeletePayload>;\n  /** Update an Episode. */\n  readonly update?: Maybe<EpisodeUpdatePayload>;\n};\n\nexport type EpisodeMutationCreateArgs = {\n  input: EpisodeCreateInput;\n};\n\nexport type EpisodeMutationDeleteArgs = {\n  input: GenericDeleteInput;\n};\n\nexport type EpisodeMutationUpdateArgs = {\n  input: EpisodeUpdateInput;\n};\n\nexport type EpisodeUpdateInput = {\n  readonly id: Scalars['ID'];\n  readonly titles?: Maybe<TitlesListInput>;\n  readonly number?: Maybe<Scalars['Int']>;\n  readonly description?: Maybe<Scalars['Map']>;\n  readonly length?: Maybe<Scalars['Int']>;\n  readonly releasedAt?: Maybe<Scalars['Date']>;\n  readonly thumbnailImage?: Maybe<Scalars['Upload']>;\n};\n\n/** Autogenerated return type of EpisodeUpdate */\nexport type EpisodeUpdatePayload = {\n  readonly __typename?: 'EpisodeUpdatePayload';\n  readonly episode?: Maybe<Episode>;\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** An episodic media in the Kitsu database */\nexport type Episodic = {\n  /** The number of episodes in this series */\n  readonly episodeCount?: Maybe<Scalars['Int']>;\n  /** The general length (in seconds) of each episode */\n  readonly episodeLength?: Maybe<Scalars['Int']>;\n  /** Episodes for this media */\n  readonly episodes: EpisodeConnection;\n  /** The total length (in seconds) of the entire series */\n  readonly totalLength?: Maybe<Scalars['Int']>;\n};\n\n/** An episodic media in the Kitsu database */\nexport type EpisodicEpisodesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  number?: Maybe<ReadonlyArray<Scalars['Int']>>;\n};\n\n/** Favorite media, characters, and people for a user */\nexport type Favorite = WithTimestamps & {\n  readonly __typename?: 'Favorite';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The kitsu object that is mapped */\n  readonly item: FavoriteItemUnion;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** The user who favorited this item */\n  readonly user: Profile;\n};\n\n/** The connection type for Favorite. */\nexport type FavoriteConnection = {\n  readonly __typename?: 'FavoriteConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<FavoriteEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Favorite>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type FavoriteEdge = {\n  readonly __typename?: 'FavoriteEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Favorite>;\n};\n\n/** Objects which are Favoritable */\nexport type FavoriteItemUnion = Anime | Character | Manga | Person;\n\nexport type Generic = Base & {\n  readonly __typename?: 'Generic';\n  /** The error code. */\n  readonly code?: Maybe<Scalars['String']>;\n  /** A description of the error */\n  readonly message: Scalars['String'];\n  /** Which input value this error came from */\n  readonly path?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\nexport type GenericDelete = {\n  readonly __typename?: 'GenericDelete';\n  readonly id: Scalars['ID'];\n};\n\nexport type GenericDeleteInput = {\n  readonly id: Scalars['ID'];\n};\n\nexport type Image = {\n  readonly __typename?: 'Image';\n  /** A blurhash-encoded version of this image */\n  readonly blurhash?: Maybe<Scalars['String']>;\n  /** The original image */\n  readonly original: ImageView;\n  /** The various generated views of this image */\n  readonly views: ReadonlyArray<ImageView>;\n};\n\nexport type ImageViewsArgs = {\n  names?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\nexport type ImageView = WithTimestamps & {\n  readonly __typename?: 'ImageView';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** The height of the image */\n  readonly height?: Maybe<Scalars['Int']>;\n  /** The name of this view of the image */\n  readonly name: Scalars['String'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** The URL of this view of the image */\n  readonly url: Scalars['String'];\n  /** The width of the image */\n  readonly width?: Maybe<Scalars['Int']>;\n};\n\n/** The user library filterable by media_type and status */\nexport type Library = {\n  readonly __typename?: 'Library';\n  /** All Library Entries for a specific Media */\n  readonly all: LibraryEntryConnection;\n  /** Library Entries for a specific Media filtered by the completed status */\n  readonly completed: LibraryEntryConnection;\n  /** Library Entries for a specific Media filtered by the current status */\n  readonly current: LibraryEntryConnection;\n  /** Library Entries for a specific Media filtered by the dropped status */\n  readonly dropped: LibraryEntryConnection;\n  /** Library Entries for a specific Media filtered by the on_hold status */\n  readonly onHold: LibraryEntryConnection;\n  /** Library Entries for a specific Media filtered by the planned status */\n  readonly planned: LibraryEntryConnection;\n  /** Random anime or manga from this library */\n  readonly randomMedia?: Maybe<Media>;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryAllArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n  status?: Maybe<ReadonlyArray<LibraryEntryStatusEnum>>;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryCompletedArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryCurrentArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryDroppedArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryOnHoldArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryPlannedArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\n/** The user library filterable by media_type and status */\nexport type LibraryRandomMediaArgs = {\n  mediaType: MediaTypeEnum;\n  status: ReadonlyArray<LibraryEntryStatusEnum>;\n};\n\n/** Information about a specific media entry for a user */\nexport type LibraryEntry = WithTimestamps & {\n  readonly __typename?: 'LibraryEntry';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** History of user actions for this library entry. */\n  readonly events?: Maybe<LibraryEventConnection>;\n  /** When the user finished this media. */\n  readonly finishedAt?: Maybe<Scalars['ISO8601DateTime']>;\n  readonly id: Scalars['ID'];\n  /** The last unit consumed */\n  readonly lastUnit?: Maybe<Unit>;\n  /** The media related to this library entry. */\n  readonly media: Media;\n  /** The next unit to be consumed */\n  readonly nextUnit?: Maybe<Unit>;\n  /** Notes left by the profile related to this library entry. */\n  readonly notes?: Maybe<Scalars['String']>;\n  /** If the media related to the library entry is Not-Safe-for-Work. */\n  readonly nsfw: Scalars['Boolean'];\n  /** If this library entry is publicly visibile from their profile, or hidden. */\n  readonly private: Scalars['Boolean'];\n  /** The number of episodes/chapters this user has watched/read */\n  readonly progress: Scalars['Int'];\n  /** When the user last watched an episode or read a chapter of this media. */\n  readonly progressedAt?: Maybe<Scalars['ISO8601DateTime']>;\n  /** How much you enjoyed this media (lower meaning not liking). */\n  readonly rating?: Maybe<Scalars['Int']>;\n  /** The reaction based on the media of this library entry. */\n  readonly reaction?: Maybe<MediaReaction>;\n  /** Amount of times this media has been rewatched. */\n  readonly reconsumeCount: Scalars['Int'];\n  /** If the profile is currently rewatching this media. */\n  readonly reconsuming: Scalars['Boolean'];\n  /** When the user started this media. */\n  readonly startedAt?: Maybe<Scalars['ISO8601DateTime']>;\n  readonly status: LibraryEntryStatusEnum;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** The user who created this library entry. */\n  readonly user: Profile;\n  /** Volumes that the profile owns (physically or digital). */\n  readonly volumesOwned: Scalars['Int'];\n};\n\n/** Information about a specific media entry for a user */\nexport type LibraryEntryEventsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaTypes?: Maybe<ReadonlyArray<MediaTypeEnum>>;\n};\n\n/** The connection type for LibraryEntry. */\nexport type LibraryEntryConnection = {\n  readonly __typename?: 'LibraryEntryConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<LibraryEntryEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<LibraryEntry>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\nexport type LibraryEntryCreateInput = {\n  readonly userId: Scalars['ID'];\n  readonly mediaId: Scalars['ID'];\n  readonly mediaType: MediaTypeEnum;\n  readonly status: LibraryEntryStatusEnum;\n  readonly progress?: Maybe<Scalars['Int']>;\n  readonly private?: Maybe<Scalars['Boolean']>;\n  readonly notes?: Maybe<Scalars['String']>;\n  readonly reconsumeCount?: Maybe<Scalars['Int']>;\n  readonly reconsuming?: Maybe<Scalars['Boolean']>;\n  readonly volumesOwned?: Maybe<Scalars['Int']>;\n  readonly rating?: Maybe<Scalars['Int']>;\n  readonly startedAt?: Maybe<Scalars['ISO8601DateTime']>;\n  readonly finishedAt?: Maybe<Scalars['ISO8601DateTime']>;\n};\n\n/** Autogenerated return type of LibraryEntryCreate */\nexport type LibraryEntryCreatePayload = {\n  readonly __typename?: 'LibraryEntryCreatePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\n/** Autogenerated return type of LibraryEntryDelete */\nexport type LibraryEntryDeletePayload = {\n  readonly __typename?: 'LibraryEntryDeletePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<GenericDelete>;\n};\n\n/** An edge in a connection. */\nexport type LibraryEntryEdge = {\n  readonly __typename?: 'LibraryEntryEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryMutation = {\n  readonly __typename?: 'LibraryEntryMutation';\n  /** Create a library entry */\n  readonly create?: Maybe<LibraryEntryCreatePayload>;\n  /** Delete a library entry */\n  readonly delete?: Maybe<LibraryEntryDeletePayload>;\n  /** Update a library entry */\n  readonly update?: Maybe<LibraryEntryUpdatePayload>;\n  /** Update library entry progress by id */\n  readonly updateProgressById?: Maybe<LibraryEntryUpdateProgressByIdPayload>;\n  /** Update library entry progress by media */\n  readonly updateProgressByMedia?: Maybe<LibraryEntryUpdateProgressByMediaPayload>;\n  /** Update library entry rating by id */\n  readonly updateRatingById?: Maybe<LibraryEntryUpdateRatingByIdPayload>;\n  /** Update library entry rating by media */\n  readonly updateRatingByMedia?: Maybe<LibraryEntryUpdateRatingByMediaPayload>;\n  /** Update library entry status by id */\n  readonly updateStatusById?: Maybe<LibraryEntryUpdateStatusByIdPayload>;\n  /** Update library entry status by media */\n  readonly updateStatusByMedia?: Maybe<LibraryEntryUpdateStatusByMediaPayload>;\n};\n\nexport type LibraryEntryMutationCreateArgs = {\n  input: LibraryEntryCreateInput;\n};\n\nexport type LibraryEntryMutationDeleteArgs = {\n  input: GenericDeleteInput;\n};\n\nexport type LibraryEntryMutationUpdateArgs = {\n  input: LibraryEntryUpdateInput;\n};\n\nexport type LibraryEntryMutationUpdateProgressByIdArgs = {\n  input: LibraryEntryUpdateProgressByIdInput;\n};\n\nexport type LibraryEntryMutationUpdateProgressByMediaArgs = {\n  input: LibraryEntryUpdateProgressByMediaInput;\n};\n\nexport type LibraryEntryMutationUpdateRatingByIdArgs = {\n  input: LibraryEntryUpdateRatingByIdInput;\n};\n\nexport type LibraryEntryMutationUpdateRatingByMediaArgs = {\n  input: LibraryEntryUpdateRatingByMediaInput;\n};\n\nexport type LibraryEntryMutationUpdateStatusByIdArgs = {\n  input: LibraryEntryUpdateStatusByIdInput;\n};\n\nexport type LibraryEntryMutationUpdateStatusByMediaArgs = {\n  input: LibraryEntryUpdateStatusByMediaInput;\n};\n\nexport enum LibraryEntryStatusEnum {\n  /** The user is currently reading or watching this media. */\n  Current = 'CURRENT',\n  /** The user plans to read or watch this media in future. */\n  Planned = 'PLANNED',\n  /** The user completed this media. */\n  Completed = 'COMPLETED',\n  /** The user started but paused reading or watching this media. */\n  OnHold = 'ON_HOLD',\n  /** The user started but chose not to finish this media. */\n  Dropped = 'DROPPED',\n}\n\nexport type LibraryEntryUpdateInput = {\n  readonly id: Scalars['ID'];\n  readonly status?: Maybe<LibraryEntryStatusEnum>;\n  readonly progress?: Maybe<Scalars['Int']>;\n  readonly private?: Maybe<Scalars['Boolean']>;\n  readonly notes?: Maybe<Scalars['String']>;\n  readonly reconsumeCount?: Maybe<Scalars['Int']>;\n  readonly reconsuming?: Maybe<Scalars['Boolean']>;\n  readonly volumesOwned?: Maybe<Scalars['Int']>;\n  readonly rating?: Maybe<Scalars['Int']>;\n  readonly startedAt?: Maybe<Scalars['ISO8601DateTime']>;\n  readonly finishedAt?: Maybe<Scalars['ISO8601DateTime']>;\n};\n\n/** Autogenerated return type of LibraryEntryUpdate */\nexport type LibraryEntryUpdatePayload = {\n  readonly __typename?: 'LibraryEntryUpdatePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryUpdateProgressByIdInput = {\n  readonly id: Scalars['ID'];\n  readonly progress: Scalars['Int'];\n};\n\n/** Autogenerated return type of LibraryEntryUpdateProgressById */\nexport type LibraryEntryUpdateProgressByIdPayload = {\n  readonly __typename?: 'LibraryEntryUpdateProgressByIdPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryUpdateProgressByMediaInput = {\n  readonly mediaId: Scalars['ID'];\n  readonly mediaType: MediaTypeEnum;\n  readonly progress: Scalars['Int'];\n};\n\n/** Autogenerated return type of LibraryEntryUpdateProgressByMedia */\nexport type LibraryEntryUpdateProgressByMediaPayload = {\n  readonly __typename?: 'LibraryEntryUpdateProgressByMediaPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryUpdateRatingByIdInput = {\n  readonly id: Scalars['ID'];\n  /** A number between 2 - 20 */\n  readonly rating: Scalars['Int'];\n};\n\n/** Autogenerated return type of LibraryEntryUpdateRatingById */\nexport type LibraryEntryUpdateRatingByIdPayload = {\n  readonly __typename?: 'LibraryEntryUpdateRatingByIdPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryUpdateRatingByMediaInput = {\n  readonly mediaId: Scalars['ID'];\n  readonly mediaType: MediaTypeEnum;\n  /** A number between 2 - 20 */\n  readonly rating: Scalars['Int'];\n};\n\n/** Autogenerated return type of LibraryEntryUpdateRatingByMedia */\nexport type LibraryEntryUpdateRatingByMediaPayload = {\n  readonly __typename?: 'LibraryEntryUpdateRatingByMediaPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryUpdateStatusByIdInput = {\n  readonly id: Scalars['ID'];\n  readonly status: LibraryEntryStatusEnum;\n};\n\n/** Autogenerated return type of LibraryEntryUpdateStatusById */\nexport type LibraryEntryUpdateStatusByIdPayload = {\n  readonly __typename?: 'LibraryEntryUpdateStatusByIdPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\nexport type LibraryEntryUpdateStatusByMediaInput = {\n  readonly mediaId: Scalars['ID'];\n  readonly mediaType: MediaTypeEnum;\n  readonly status: LibraryEntryStatusEnum;\n};\n\n/** Autogenerated return type of LibraryEntryUpdateStatusByMedia */\nexport type LibraryEntryUpdateStatusByMediaPayload = {\n  readonly __typename?: 'LibraryEntryUpdateStatusByMediaPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly libraryEntry?: Maybe<LibraryEntry>;\n};\n\n/** History of user actions for a library entry. */\nexport type LibraryEvent = WithTimestamps & {\n  readonly __typename?: 'LibraryEvent';\n  /** The data that was changed for this library event. */\n  readonly changedData: Scalars['Map'];\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The type of library event. */\n  readonly kind: LibraryEventKindEnum;\n  /** The library entry related to this library event. */\n  readonly libraryEntry: LibraryEntry;\n  /** The media related to this library event. */\n  readonly media: Media;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** The user who created this library event */\n  readonly user: Profile;\n};\n\n/** The connection type for LibraryEvent. */\nexport type LibraryEventConnection = {\n  readonly __typename?: 'LibraryEventConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<LibraryEventEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<LibraryEvent>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type LibraryEventEdge = {\n  readonly __typename?: 'LibraryEventEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<LibraryEvent>;\n};\n\nexport enum LibraryEventKindEnum {\n  /** Progress or Time Spent was added/updated. */\n  Progressed = 'PROGRESSED',\n  /** Status or Reconsuming was added/updated. */\n  Updated = 'UPDATED',\n  /** Reaction was added/updated. */\n  Reacted = 'REACTED',\n  /** Rating was added/updated. */\n  Rated = 'RATED',\n  /** Notes were added/updated. */\n  Annotated = 'ANNOTATED',\n}\n\nexport type LockInput = {\n  readonly id: Scalars['ID'];\n  readonly lockedReason: LockedReasonEnum;\n};\n\n/** Autogenerated return type of LockPost */\nexport type LockPostPayload = {\n  readonly __typename?: 'LockPostPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly post?: Maybe<Post>;\n};\n\nexport enum LockedReasonEnum {\n  Spam = 'SPAM',\n  TooHeated = 'TOO_HEATED',\n  Closed = 'CLOSED',\n}\n\nexport type Manga = Media &\n  WithTimestamps & {\n    readonly __typename?: 'Manga';\n    /** The recommended minimum age group for this media */\n    readonly ageRating?: Maybe<AgeRatingEnum>;\n    /** An explanation of why this received the age rating it did */\n    readonly ageRatingGuide?: Maybe<Scalars['String']>;\n    /** The average rating of this media amongst all Kitsu users */\n    readonly averageRating?: Maybe<Scalars['Float']>;\n    /** A large banner image for this media */\n    readonly bannerImage: Image;\n    /** A list of categories for this media */\n    readonly categories: CategoryConnection;\n    /** The number of chapters in this manga. */\n    readonly chapterCount?: Maybe<Scalars['Int']>;\n    /** The estimated number of chapters in this manga. */\n    readonly chapterCountGuess?: Maybe<Scalars['Int']>;\n    /** The chapters in the manga. */\n    readonly chapters?: Maybe<ChapterConnection>;\n    /** The characters who starred in this media */\n    readonly characters: MediaCharacterConnection;\n    readonly createdAt: Scalars['ISO8601DateTime'];\n    /** A brief (mostly spoiler free) summary or description of the media. */\n    readonly description: Scalars['Map'];\n    /** the day that this media made its final release */\n    readonly endDate?: Maybe<Scalars['Date']>;\n    /** The number of users with this in their favorites */\n    readonly favoritesCount?: Maybe<Scalars['Int']>;\n    readonly id: Scalars['ID'];\n    /** A list of mappings for this media */\n    readonly mappings: MappingConnection;\n    /** The time of the next release of this media */\n    readonly nextRelease?: Maybe<Scalars['ISO8601DateTime']>;\n    /** The poster image of this media */\n    readonly posterImage: Image;\n    /** The companies which helped to produce this media */\n    readonly productions: MediaProductionConnection;\n    /** A list of quotes from this media */\n    readonly quotes: QuoteConnection;\n    /** A list of reactions for this media */\n    readonly reactions: MediaReactionConnection;\n    /** The season this was released in */\n    readonly season?: Maybe<ReleaseSeasonEnum>;\n    /** Whether the media is Safe-for-Work */\n    readonly sfw: Scalars['Boolean'];\n    /** The URL-friendly identifier of this media */\n    readonly slug: Scalars['String'];\n    /** The staff members who worked on this media */\n    readonly staff: MediaStaffConnection;\n    /** The day that this media first released */\n    readonly startDate?: Maybe<Scalars['Date']>;\n    /** The current releasing status of this media */\n    readonly status: ReleaseStatusEnum;\n    /** A secondary type for categorizing Manga. */\n    readonly subtype: MangaSubtypeEnum;\n    /** Description of when this media is expected to release */\n    readonly tba?: Maybe<Scalars['String']>;\n    /** The titles for this media in various locales */\n    readonly titles: TitlesList;\n    /** Anime or Manga. */\n    readonly type: Scalars['String'];\n    readonly updatedAt: Scalars['ISO8601DateTime'];\n    /** The number of users with this in their library */\n    readonly userCount?: Maybe<Scalars['Int']>;\n    /** The number of volumes in this manga. */\n    readonly volumeCount?: Maybe<Scalars['Int']>;\n  };\n\nexport type MangaCategoriesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaChaptersArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaCharactersArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\nexport type MangaMappingsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaProductionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaQuotesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaReactionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaStaffArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type MangaAmountConsumed = AmountConsumed & {\n  readonly __typename?: 'MangaAmountConsumed';\n  /** Total media completed atleast once. */\n  readonly completed: Scalars['Int'];\n  readonly id: Scalars['ID'];\n  /** Total amount of media. */\n  readonly media: Scalars['Int'];\n  /** The profile related to the user for this stat. */\n  readonly profile: Profile;\n  /** Last time we fully recalculated this stat. */\n  readonly recalculatedAt: Scalars['ISO8601Date'];\n  /** Total progress of library including reconsuming. */\n  readonly units: Scalars['Int'];\n};\n\nexport type MangaCategoryBreakdown = CategoryBreakdown & {\n  readonly __typename?: 'MangaCategoryBreakdown';\n  /** A Map of category_id -> count for all categories present on the library entries */\n  readonly categories: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** The profile related to the user for this stat. */\n  readonly profile: Profile;\n  /** Last time we fully recalculated this stat. */\n  readonly recalculatedAt: Scalars['ISO8601Date'];\n  /** The total amount of library entries. */\n  readonly total: Scalars['Int'];\n};\n\n/** The connection type for Manga. */\nexport type MangaConnection = {\n  readonly __typename?: 'MangaConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MangaEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Manga>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MangaEdge = {\n  readonly __typename?: 'MangaEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Manga>;\n};\n\nexport enum MangaSubtypeEnum {\n  Manga = 'MANGA',\n  Novel = 'NOVEL',\n  /** Chinese comics produced in China and in the Greater China region. */\n  Manhua = 'MANHUA',\n  Oneshot = 'ONESHOT',\n  /** Self published work. */\n  Doujin = 'DOUJIN',\n  /** A style of South Korean comic books and graphic novels */\n  Manhwa = 'MANHWA',\n  /** Original English Language. */\n  Oel = 'OEL',\n}\n\n/** Media Mappings from External Sites (MAL, Anilist, etc..) to Kitsu. */\nexport type Mapping = WithTimestamps & {\n  readonly __typename?: 'Mapping';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** The ID of the media from the external site. */\n  readonly externalId: Scalars['ID'];\n  /** The name of the site which kitsu media is being linked from. */\n  readonly externalSite: MappingExternalSiteEnum;\n  readonly id: Scalars['ID'];\n  /** The kitsu object that is mapped. */\n  readonly item: MappingItemUnion;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** The connection type for Mapping. */\nexport type MappingConnection = {\n  readonly __typename?: 'MappingConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MappingEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Mapping>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\nexport type MappingCreateInput = {\n  readonly externalSite: MappingExternalSiteEnum;\n  readonly externalId: Scalars['ID'];\n  readonly itemId: Scalars['ID'];\n  readonly itemType: MappingItemEnum;\n};\n\n/** Autogenerated return type of MappingCreate */\nexport type MappingCreatePayload = {\n  readonly __typename?: 'MappingCreatePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly mapping?: Maybe<Mapping>;\n};\n\n/** Autogenerated return type of MappingDelete */\nexport type MappingDeletePayload = {\n  readonly __typename?: 'MappingDeletePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly mapping?: Maybe<GenericDelete>;\n};\n\n/** An edge in a connection. */\nexport type MappingEdge = {\n  readonly __typename?: 'MappingEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Mapping>;\n};\n\nexport enum MappingExternalSiteEnum {\n  MyanimelistAnime = 'MYANIMELIST_ANIME',\n  MyanimelistManga = 'MYANIMELIST_MANGA',\n  MyanimelistCharacters = 'MYANIMELIST_CHARACTERS',\n  MyanimelistPeople = 'MYANIMELIST_PEOPLE',\n  MyanimelistProducers = 'MYANIMELIST_PRODUCERS',\n  AnilistAnime = 'ANILIST_ANIME',\n  AnilistManga = 'ANILIST_MANGA',\n  Thetvdb = 'THETVDB',\n  ThetvdbSeries = 'THETVDB_SERIES',\n  ThetvdbSeason = 'THETVDB_SEASON',\n  Anidb = 'ANIDB',\n  Animenewsnetwork = 'ANIMENEWSNETWORK',\n  Mangaupdates = 'MANGAUPDATES',\n  Hulu = 'HULU',\n  ImdbEpisodes = 'IMDB_EPISODES',\n  Aozora = 'AOZORA',\n  Trakt = 'TRAKT',\n  Mydramalist = 'MYDRAMALIST',\n}\n\nexport enum MappingItemEnum {\n  Anime = 'ANIME',\n  Manga = 'MANGA',\n  Category = 'CATEGORY',\n  Character = 'CHARACTER',\n  Episode = 'EPISODE',\n  Person = 'PERSON',\n  Producer = 'PRODUCER',\n}\n\n/** Objects which are Mappable */\nexport type MappingItemUnion =\n  | Anime\n  | Category\n  | Character\n  | Episode\n  | Manga\n  | Person\n  | Producer;\n\nexport type MappingMutation = {\n  readonly __typename?: 'MappingMutation';\n  /** Create a Mapping */\n  readonly create?: Maybe<MappingCreatePayload>;\n  /** Delete a Mapping */\n  readonly delete?: Maybe<MappingDeletePayload>;\n  /** Update a Mapping */\n  readonly update?: Maybe<MappingUpdatePayload>;\n};\n\nexport type MappingMutationCreateArgs = {\n  input: MappingCreateInput;\n};\n\nexport type MappingMutationDeleteArgs = {\n  input: GenericDeleteInput;\n};\n\nexport type MappingMutationUpdateArgs = {\n  input: MappingUpdateInput;\n};\n\nexport type MappingUpdateInput = {\n  readonly id: Scalars['ID'];\n  readonly externalSite?: Maybe<MappingExternalSiteEnum>;\n  readonly externalId?: Maybe<Scalars['ID']>;\n  readonly itemId?: Maybe<Scalars['ID']>;\n  readonly itemType?: Maybe<MappingItemEnum>;\n};\n\n/** Autogenerated return type of MappingUpdate */\nexport type MappingUpdatePayload = {\n  readonly __typename?: 'MappingUpdatePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly mapping?: Maybe<Mapping>;\n};\n\n/** A media in the Kitsu database */\nexport type Media = {\n  /** The recommended minimum age group for this media */\n  readonly ageRating?: Maybe<AgeRatingEnum>;\n  /** An explanation of why this received the age rating it did */\n  readonly ageRatingGuide?: Maybe<Scalars['String']>;\n  /** The average rating of this media amongst all Kitsu users */\n  readonly averageRating?: Maybe<Scalars['Float']>;\n  /** A large banner image for this media */\n  readonly bannerImage: Image;\n  /** A list of categories for this media */\n  readonly categories: CategoryConnection;\n  /** The characters who starred in this media */\n  readonly characters: MediaCharacterConnection;\n  /** A brief (mostly spoiler free) summary or description of the media. */\n  readonly description: Scalars['Map'];\n  /** the day that this media made its final release */\n  readonly endDate?: Maybe<Scalars['Date']>;\n  /** The number of users with this in their favorites */\n  readonly favoritesCount?: Maybe<Scalars['Int']>;\n  readonly id: Scalars['ID'];\n  /** A list of mappings for this media */\n  readonly mappings: MappingConnection;\n  /** The time of the next release of this media */\n  readonly nextRelease?: Maybe<Scalars['ISO8601DateTime']>;\n  /** The poster image of this media */\n  readonly posterImage: Image;\n  /** The companies which helped to produce this media */\n  readonly productions: MediaProductionConnection;\n  /** A list of quotes from this media */\n  readonly quotes: QuoteConnection;\n  /** A list of reactions for this media */\n  readonly reactions: MediaReactionConnection;\n  /** The season this was released in */\n  readonly season?: Maybe<ReleaseSeasonEnum>;\n  /** Whether the media is Safe-for-Work */\n  readonly sfw: Scalars['Boolean'];\n  /** The URL-friendly identifier of this media */\n  readonly slug: Scalars['String'];\n  /** The staff members who worked on this media */\n  readonly staff: MediaStaffConnection;\n  /** The day that this media first released */\n  readonly startDate?: Maybe<Scalars['Date']>;\n  /** The current releasing status of this media */\n  readonly status: ReleaseStatusEnum;\n  /** Description of when this media is expected to release */\n  readonly tba?: Maybe<Scalars['String']>;\n  /** The titles for this media in various locales */\n  readonly titles: TitlesList;\n  /** Anime or Manga. */\n  readonly type: Scalars['String'];\n  /** The number of users with this in their library */\n  readonly userCount?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaCategoriesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaCharactersArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaMappingsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaProductionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaQuotesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaReactionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A media in the Kitsu database */\nexport type MediaStaffArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** Information about a Character starring in a Media */\nexport type MediaCharacter = WithTimestamps & {\n  readonly __typename?: 'MediaCharacter';\n  /** The character */\n  readonly character: Character;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The media */\n  readonly media: Media;\n  /** The role this character had in the media */\n  readonly role: CharacterRoleEnum;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** The voices of this character */\n  readonly voices?: Maybe<CharacterVoiceConnection>;\n};\n\n/** Information about a Character starring in a Media */\nexport type MediaCharacterVoicesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  locale?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** The connection type for MediaCharacter. */\nexport type MediaCharacterConnection = {\n  readonly __typename?: 'MediaCharacterConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaCharacterEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaCharacter>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MediaCharacterEdge = {\n  readonly __typename?: 'MediaCharacterEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<MediaCharacter>;\n};\n\n/** The connection type for Media. */\nexport type MediaConnection = {\n  readonly __typename?: 'MediaConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Media>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n};\n\n/** An edge in a connection. */\nexport type MediaEdge = {\n  readonly __typename?: 'MediaEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Media>;\n};\n\n/** The role a company played in the creation or localization of a media */\nexport type MediaProduction = WithTimestamps & {\n  readonly __typename?: 'MediaProduction';\n  /** The production company */\n  readonly company: Producer;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The media */\n  readonly media: Media;\n  /** The role this company played */\n  readonly role: MediaProductionRoleEnum;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** The connection type for MediaProduction. */\nexport type MediaProductionConnection = {\n  readonly __typename?: 'MediaProductionConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaProductionEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaProduction>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MediaProductionEdge = {\n  readonly __typename?: 'MediaProductionEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<MediaProduction>;\n};\n\nexport enum MediaProductionRoleEnum {\n  Producer = 'PRODUCER',\n  Licensor = 'LICENSOR',\n  Studio = 'STUDIO',\n  Serialization = 'SERIALIZATION',\n}\n\n/** A simple review that is 140 characters long expressing how you felt about a media */\nexport type MediaReaction = WithTimestamps & {\n  readonly __typename?: 'MediaReaction';\n  /** The author who wrote this reaction. */\n  readonly author: Profile;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The library entry related to this reaction. */\n  readonly libraryEntry: LibraryEntry;\n  /** Users who liked this reaction. */\n  readonly likes: ProfileConnection;\n  /** The media related to this reaction. */\n  readonly media: Media;\n  /** When this media reaction was written based on media progress. */\n  readonly progress: Scalars['Int'];\n  /** The reaction text related to a media. */\n  readonly reaction: Scalars['String'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** A simple review that is 140 characters long expressing how you felt about a media */\nexport type MediaReactionLikesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The connection type for MediaReaction. */\nexport type MediaReactionConnection = {\n  readonly __typename?: 'MediaReactionConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaReactionEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaReaction>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MediaReactionEdge = {\n  readonly __typename?: 'MediaReactionEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<MediaReaction>;\n};\n\n/** Information about a person working on an anime */\nexport type MediaStaff = WithTimestamps & {\n  readonly __typename?: 'MediaStaff';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The media */\n  readonly media: Media;\n  /** The person */\n  readonly person: Person;\n  /** The role this person had in the creation of this media */\n  readonly role: Scalars['String'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** The connection type for MediaStaff. */\nexport type MediaStaffConnection = {\n  readonly __typename?: 'MediaStaffConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<MediaStaffEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<MediaStaff>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MediaStaffEdge = {\n  readonly __typename?: 'MediaStaffEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<MediaStaff>;\n};\n\n/** これはアニメやマンガです */\nexport enum MediaTypeEnum {\n  Anime = 'ANIME',\n  Manga = 'MANGA',\n}\n\nexport type Mutation = {\n  readonly __typename?: 'Mutation';\n  readonly anime?: Maybe<AnimeMutation>;\n  readonly episode?: Maybe<EpisodeMutation>;\n  readonly libraryEntry?: Maybe<LibraryEntryMutation>;\n  readonly mapping?: Maybe<MappingMutation>;\n  readonly post?: Maybe<PostMutation>;\n  readonly pro: ProMutation;\n};\n\n/** Information about pagination in a connection. */\nexport type PageInfo = {\n  readonly __typename?: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  readonly endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  readonly hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  readonly hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  readonly startCursor?: Maybe<Scalars['String']>;\n};\n\n/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */\nexport type Person = WithTimestamps & {\n  readonly __typename?: 'Person';\n  /** The day when this person was born */\n  readonly birthday?: Maybe<Scalars['Date']>;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** A brief biography or description of the person. */\n  readonly description: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** An image of the person */\n  readonly image?: Maybe<Image>;\n  /** Information about the person working on specific media */\n  readonly mediaStaff?: Maybe<MediaStaffConnection>;\n  /** The primary name of this person. */\n  readonly name: Scalars['String'];\n  /** The name of this person in various languages */\n  readonly names: TitlesList;\n  /** The URL-friendly identifier of this person. */\n  readonly slug: Scalars['String'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** The voice-acting roles this person has had. */\n  readonly voices?: Maybe<CharacterVoiceConnection>;\n};\n\n/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */\nexport type PersonDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\n/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */\nexport type PersonMediaStaffArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A Voice Actor, Director, Animator, or other person who works in the creation and localization of media */\nexport type PersonVoicesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A post that is visible to your followers and globally in the news-feed. */\nexport type Post = WithTimestamps & {\n  readonly __typename?: 'Post';\n  /** The user who created this post. */\n  readonly author: Profile;\n  /** All comments related to this post. */\n  readonly comments: CommentConnection;\n  /** Unmodified content. */\n  readonly content: Scalars['String'];\n  /** Html formatted content. */\n  readonly contentFormatted: Scalars['String'];\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** Users that are watching this post */\n  readonly follows: ProfileConnection;\n  readonly id: Scalars['ID'];\n  /** If a post is Not-Safe-for-Work. */\n  readonly isNsfw: Scalars['Boolean'];\n  /** If this post spoils the tagged media. */\n  readonly isSpoiler: Scalars['Boolean'];\n  /** Users that have liked this post. */\n  readonly likes: ProfileConnection;\n  /** When this post was locked. */\n  readonly lockedAt?: Maybe<Scalars['ISO8601DateTime']>;\n  /** The user who locked this post. */\n  readonly lockedBy?: Maybe<Profile>;\n  /** The reason why this post was locked. */\n  readonly lockedReason?: Maybe<LockedReasonEnum>;\n  /** The media tagged in this post. */\n  readonly media?: Maybe<Media>;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** A post that is visible to your followers and globally in the news-feed. */\nexport type PostCommentsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A post that is visible to your followers and globally in the news-feed. */\nexport type PostFollowsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A post that is visible to your followers and globally in the news-feed. */\nexport type PostLikesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The connection type for Post. */\nexport type PostConnection = {\n  readonly __typename?: 'PostConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<PostEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Post>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PostEdge = {\n  readonly __typename?: 'PostEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Post>;\n};\n\nexport type PostMutation = {\n  readonly __typename?: 'PostMutation';\n  /** Lock a Post. */\n  readonly lock?: Maybe<LockPostPayload>;\n  /** Unlock a Post. */\n  readonly unlock?: Maybe<UnlockPostPayload>;\n};\n\nexport type PostMutationLockArgs = {\n  input: LockInput;\n};\n\nexport type PostMutationUnlockArgs = {\n  input: UnlockInput;\n};\n\nexport type ProMutation = {\n  readonly __typename?: 'ProMutation';\n  /** Set the user's discord tag */\n  readonly setDiscord?: Maybe<SetDiscordPayload>;\n  /** Set the user's Hall-of-Fame message */\n  readonly setMessage?: Maybe<SetMessagePayload>;\n  /** End the user's pro subscription */\n  readonly unsubscribe?: Maybe<UnsubscribePayload>;\n};\n\nexport type ProMutationSetDiscordArgs = {\n  discord: Scalars['String'];\n};\n\nexport type ProMutationSetMessageArgs = {\n  message: Scalars['String'];\n};\n\n/** A subscription to Kitsu PRO */\nexport type ProSubscription = WithTimestamps & {\n  readonly __typename?: 'ProSubscription';\n  /** The account which is subscribed to Pro benefits */\n  readonly account: Account;\n  /** The billing service used for this subscription */\n  readonly billingService: RecurringBillingServiceEnum;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** The tier of Pro the account is subscribed to */\n  readonly tier: ProTierEnum;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\nexport enum ProTierEnum {\n  /** Aozora Pro (only hides ads) */\n  AoPro = 'AO_PRO',\n  /** Aozora Pro+ (only hides ads) */\n  AoProPlus = 'AO_PRO_PLUS',\n  /** Basic tier of Kitsu Pro */\n  Pro = 'PRO',\n  /** Top tier of Kitsu Pro */\n  Patron = 'PATRON',\n}\n\n/** A company involved in the creation or localization of media */\nexport type Producer = WithTimestamps & {\n  readonly __typename?: 'Producer';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The name of this production company */\n  readonly name: Scalars['String'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** A user profile on Kitsu */\nexport type Profile = WithTimestamps & {\n  readonly __typename?: 'Profile';\n  /** A short biographical blurb about this profile */\n  readonly about?: Maybe<Scalars['String']>;\n  /** An avatar image to easily identify this profile */\n  readonly avatarImage?: Maybe<Image>;\n  /** A banner to display at the top of the profile */\n  readonly bannerImage?: Maybe<Image>;\n  /** When the user was born */\n  readonly birthday?: Maybe<Scalars['ISO8601Date']>;\n  /** All comments to any post this user has made. */\n  readonly comments: CommentConnection;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  /** Favorite media, characters, and people */\n  readonly favorites: FavoriteConnection;\n  /** People that follow the user */\n  readonly followers: ProfileConnection;\n  /** People the user is following */\n  readonly following: ProfileConnection;\n  /** What the user identifies as */\n  readonly gender?: Maybe<Scalars['String']>;\n  readonly id: Scalars['ID'];\n  /** The user library of their media */\n  readonly library: Library;\n  /** A list of library events for this user */\n  readonly libraryEvents: LibraryEventConnection;\n  /** The user's general location */\n  readonly location?: Maybe<Scalars['String']>;\n  /** Media reactions written by this user. */\n  readonly mediaReactions: MediaReactionConnection;\n  /** A non-unique publicly visible name for the profile. Minimum of 3 characters and any valid Unicode character */\n  readonly name: Scalars['String'];\n  /** Post pinned to the user profile */\n  readonly pinnedPost?: Maybe<Post>;\n  /** All posts this profile has made. */\n  readonly posts: PostConnection;\n  /** The message this user has submitted to the Hall of Fame */\n  readonly proMessage?: Maybe<Scalars['String']>;\n  /** The PRO level the user currently has */\n  readonly proTier?: Maybe<ProTierEnum>;\n  /** Links to the user on other (social media) sites. */\n  readonly siteLinks?: Maybe<SiteLinkConnection>;\n  /** The URL-friendly identifier for this profile */\n  readonly slug?: Maybe<Scalars['String']>;\n  /** The different stats we calculate for this user. */\n  readonly stats: ProfileStats;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** A fully qualified URL to the profile */\n  readonly url?: Maybe<Scalars['String']>;\n  /** The character this profile has declared as their waifu or husbando */\n  readonly waifu?: Maybe<Character>;\n  /** The properly-gendered term for the user's waifu. This should normally only be 'Waifu' or 'Husbando' but some people are jerks, including the person who wrote this... */\n  readonly waifuOrHusbando?: Maybe<Scalars['String']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileCommentsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileFavoritesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileFollowersArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileFollowingArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileLibraryEventsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  kind?: Maybe<ReadonlyArray<LibraryEventKindEnum>>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileMediaReactionsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfilePostsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** A user profile on Kitsu */\nexport type ProfileSiteLinksArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The connection type for Profile. */\nexport type ProfileConnection = {\n  readonly __typename?: 'ProfileConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<ProfileEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Profile>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProfileEdge = {\n  readonly __typename?: 'ProfileEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Profile>;\n};\n\n/** The different types of user stats that we calculate. */\nexport type ProfileStats = {\n  readonly __typename?: 'ProfileStats';\n  /** The total amount of anime you have watched over your whole life. */\n  readonly animeAmountConsumed: AnimeAmountConsumed;\n  /** The breakdown of the different categories related to the anime you have completed */\n  readonly animeCategoryBreakdown: AnimeCategoryBreakdown;\n  /** The total amount of manga you ahve read over your whole life. */\n  readonly mangaAmountConsumed: MangaAmountConsumed;\n  /** The breakdown of the different categories related to the manga you have completed */\n  readonly mangaCategoryBreakdown: MangaCategoryBreakdown;\n};\n\nexport type Query = {\n  readonly __typename?: 'Query';\n  /** All Anime in the Kitsu database */\n  readonly anime: AnimeConnection;\n  /** All Anime with specific Status */\n  readonly animeByStatus?: Maybe<AnimeConnection>;\n  /** All Categories in the Kitsu Database */\n  readonly categories?: Maybe<CategoryConnection>;\n  /** Kitsu account details. You must supply an Authorization token in header. */\n  readonly currentAccount?: Maybe<Account>;\n  /** Find a single Anime by ID */\n  readonly findAnimeById?: Maybe<Anime>;\n  /** Find a single Anime by Slug */\n  readonly findAnimeBySlug?: Maybe<Anime>;\n  /** Find a single Category by ID */\n  readonly findCategoryById?: Maybe<Category>;\n  /** Find a single Category by Slug */\n  readonly findCategoryBySlug?: Maybe<Category>;\n  /** Find a single Character by ID */\n  readonly findCharacterById?: Maybe<Character>;\n  /** Find a single Character by Slug */\n  readonly findCharacterBySlug?: Maybe<Character>;\n  /** Find a single Library Entry by ID */\n  readonly findLibraryEntryById?: Maybe<LibraryEntry>;\n  /** Find a single Library Event by ID */\n  readonly findLibraryEventById?: Maybe<LibraryEvent>;\n  /** Find a single Manga by ID */\n  readonly findMangaById?: Maybe<Manga>;\n  /** Find a single Manga by Slug */\n  readonly findMangaBySlug?: Maybe<Manga>;\n  /** Find a single Person by ID */\n  readonly findPersonById?: Maybe<Person>;\n  /** Find a single Person by Slug */\n  readonly findPersonBySlug?: Maybe<Person>;\n  /** Find a single Post by ID */\n  readonly findPostById?: Maybe<Post>;\n  /** Find a single User by ID */\n  readonly findProfileById?: Maybe<Profile>;\n  /** Find a single User by Slug */\n  readonly findProfileBySlug?: Maybe<Profile>;\n  /** List trending media on Kitsu */\n  readonly globalTrending: MediaConnection;\n  /** List of Library Entries by MediaType and MediaId */\n  readonly libraryEntriesByMedia?: Maybe<LibraryEntryConnection>;\n  /** List of Library Entries by MediaType */\n  readonly libraryEntriesByMediaType?: Maybe<LibraryEntryConnection>;\n  /** List trending media within your network */\n  readonly localTrending: MediaConnection;\n  /** Find a specific Mapping Item by External ID and External Site. */\n  readonly lookupMapping?: Maybe<MappingItemUnion>;\n  /** All Manga in the Kitsu database */\n  readonly manga: MangaConnection;\n  /** All Manga with specific Status */\n  readonly mangaByStatus?: Maybe<MangaConnection>;\n  /** Patrons sorted by a Proprietary Magic Algorithm */\n  readonly patrons: ProfileConnection;\n  /** Random anime or manga */\n  readonly randomMedia: Media;\n  /** Search for Anime by title using Algolia. The most relevant results will be at the top. */\n  readonly searchAnimeByTitle: AnimeConnection;\n  /** Search for Manga by title using Algolia. The most relevant results will be at the top. */\n  readonly searchMangaByTitle: MangaConnection;\n  /** Search for any media (Anime, Manga) by title using Algolia. If no media_type is supplied, it will search for both. The most relevant results will be at the top. */\n  readonly searchMediaByTitle: MediaConnection;\n  /** Search for User by username using Algolia. The most relevant results will be at the top. */\n  readonly searchProfileByUsername?: Maybe<ProfileConnection>;\n  /** Get your current session info */\n  readonly session: Session;\n};\n\nexport type QueryAnimeArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type QueryAnimeByStatusArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  status: ReleaseStatusEnum;\n};\n\nexport type QueryCategoriesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type QueryFindAnimeByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindAnimeBySlugArgs = {\n  slug: Scalars['String'];\n};\n\nexport type QueryFindCategoryByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindCategoryBySlugArgs = {\n  slug: Scalars['String'];\n};\n\nexport type QueryFindCharacterByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindCharacterBySlugArgs = {\n  slug: Scalars['String'];\n};\n\nexport type QueryFindLibraryEntryByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindLibraryEventByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindMangaByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindMangaBySlugArgs = {\n  slug: Scalars['String'];\n};\n\nexport type QueryFindPersonByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindPersonBySlugArgs = {\n  slug: Scalars['String'];\n};\n\nexport type QueryFindPostByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindProfileByIdArgs = {\n  id: Scalars['ID'];\n};\n\nexport type QueryFindProfileBySlugArgs = {\n  slug: Scalars['String'];\n};\n\nexport type QueryGlobalTrendingArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\nexport type QueryLibraryEntriesByMediaArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n  mediaId: Scalars['ID'];\n};\n\nexport type QueryLibraryEntriesByMediaTypeArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\nexport type QueryLocalTrendingArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  mediaType: MediaTypeEnum;\n};\n\nexport type QueryLookupMappingArgs = {\n  externalId: Scalars['ID'];\n  externalSite: MappingExternalSiteEnum;\n};\n\nexport type QueryMangaArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type QueryMangaByStatusArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  status: ReleaseStatusEnum;\n};\n\nexport type QueryPatronsArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type QueryRandomMediaArgs = {\n  mediaType: MediaTypeEnum;\n  ageRatings: ReadonlyArray<AgeRatingEnum>;\n};\n\nexport type QuerySearchAnimeByTitleArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  title: Scalars['String'];\n};\n\nexport type QuerySearchMangaByTitleArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  title: Scalars['String'];\n};\n\nexport type QuerySearchMediaByTitleArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  title: Scalars['String'];\n  mediaType?: Maybe<MediaTypeEnum>;\n};\n\nexport type QuerySearchProfileByUsernameArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n  username: Scalars['String'];\n};\n\n/** A quote from a media */\nexport type Quote = WithTimestamps & {\n  readonly __typename?: 'Quote';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The lines of the quote */\n  readonly lines: QuoteLineConnection;\n  /** The media this quote is excerpted from */\n  readonly media: Media;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** A quote from a media */\nexport type QuoteLinesArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The connection type for Quote. */\nexport type QuoteConnection = {\n  readonly __typename?: 'QuoteConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<QuoteEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Quote>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type QuoteEdge = {\n  readonly __typename?: 'QuoteEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Quote>;\n};\n\n/** A line in a quote */\nexport type QuoteLine = WithTimestamps & {\n  readonly __typename?: 'QuoteLine';\n  /** The character who said this line */\n  readonly character: Character;\n  /** The line that was spoken */\n  readonly content: Scalars['String'];\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The quote this line is in */\n  readonly quote: Quote;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** The connection type for QuoteLine. */\nexport type QuoteLineConnection = {\n  readonly __typename?: 'QuoteLineConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<QuoteLineEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<QuoteLine>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type QuoteLineEdge = {\n  readonly __typename?: 'QuoteLineEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<QuoteLine>;\n};\n\nexport enum RatingSystemEnum {\n  /** 1-20 displayed as 4 smileys - Awful (1), Meh (8), Good (14) and Great (20) */\n  Simple = 'SIMPLE',\n  /** 1-20 in increments of 2 displayed as 5 stars in 0.5 star increments */\n  Regular = 'REGULAR',\n  /** 1-20 in increments of 1 displayed as 1-10 in 0.5 increments */\n  Advanced = 'ADVANCED',\n}\n\nexport enum RecurringBillingServiceEnum {\n  /** Bill a credit card via Stripe */\n  Stripe = 'STRIPE',\n  /** Bill a PayPal account */\n  Paypal = 'PAYPAL',\n  /** Billed through Apple In-App Subscription */\n  Apple = 'APPLE',\n  /** Billed through Google Play Subscription */\n  GooglePlay = 'GOOGLE_PLAY',\n}\n\nexport enum ReleaseSeasonEnum {\n  /** Released during the Winter season */\n  Winter = 'WINTER',\n  /** Released during the Spring season */\n  Spring = 'SPRING',\n  /** Released during the Summer season */\n  Summer = 'SUMMER',\n  /** Released during the Fall season */\n  Fall = 'FALL',\n}\n\nexport enum ReleaseStatusEnum {\n  /** The release date has not been announced yet */\n  Tba = 'TBA',\n  /** This media is no longer releasing */\n  Finished = 'FINISHED',\n  /** This media is currently releasing */\n  Current = 'CURRENT',\n  /** This media is releasing soon */\n  Upcoming = 'UPCOMING',\n  /** This media is not released yet */\n  Unreleased = 'UNRELEASED',\n}\n\n/** Information about a user session */\nexport type Session = {\n  readonly __typename?: 'Session';\n  /** The account associated with this session */\n  readonly account?: Maybe<Account>;\n  /** The profile associated with this session */\n  readonly profile?: Maybe<Profile>;\n};\n\n/** Autogenerated return type of SetDiscord */\nexport type SetDiscordPayload = {\n  readonly __typename?: 'SetDiscordPayload';\n  readonly discord: Scalars['String'];\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n};\n\n/** Autogenerated return type of SetMessage */\nexport type SetMessagePayload = {\n  readonly __typename?: 'SetMessagePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly message: Scalars['String'];\n};\n\n/** A link to a user's profile on an external site. */\nexport type SiteLink = WithTimestamps & {\n  readonly __typename?: 'SiteLink';\n  /** The user profile the site is linked to. */\n  readonly author: Profile;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** A fully qualified URL of the user profile on an external site. */\n  readonly url: Scalars['String'];\n};\n\n/** The connection type for SiteLink. */\nexport type SiteLinkConnection = {\n  readonly __typename?: 'SiteLinkConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<SiteLinkEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<SiteLink>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SiteLinkEdge = {\n  readonly __typename?: 'SiteLinkEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<SiteLink>;\n};\n\nexport enum SitePermissionEnum {\n  /** Administrator/staff member of Kitsu */\n  Admin = 'ADMIN',\n  /** Moderator of community behavior */\n  CommunityMod = 'COMMUNITY_MOD',\n  /** Maintainer of the Kitsu media database */\n  DatabaseMod = 'DATABASE_MOD',\n}\n\n/** Media that is streamable. */\nexport type Streamable = {\n  /** Spoken language is replaced by language of choice. */\n  readonly dubs: ReadonlyArray<Scalars['String']>;\n  /** Which regions this video is available in. */\n  readonly regions: ReadonlyArray<Scalars['String']>;\n  /** The site that is streaming this media. */\n  readonly streamer: Streamer;\n  /** Languages this is translated to. Usually placed at bottom of media. */\n  readonly subs: ReadonlyArray<Scalars['String']>;\n};\n\n/** The streaming company. */\nexport type Streamer = WithTimestamps & {\n  readonly __typename?: 'Streamer';\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The name of the site that is streaming this media. */\n  readonly siteName: Scalars['String'];\n  /** Additional media this site is streaming. */\n  readonly streamingLinks: StreamingLinkConnection;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n  /** Videos of the media being streamed. */\n  readonly videos: VideoConnection;\n};\n\n/** The streaming company. */\nexport type StreamerStreamingLinksArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The streaming company. */\nexport type StreamerVideosArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\n/** The stream link. */\nexport type StreamingLink = Streamable &\n  WithTimestamps & {\n    readonly __typename?: 'StreamingLink';\n    readonly createdAt: Scalars['ISO8601DateTime'];\n    /** Spoken language is replaced by language of choice. */\n    readonly dubs: ReadonlyArray<Scalars['String']>;\n    readonly id: Scalars['ID'];\n    /** The media being streamed */\n    readonly media: Media;\n    /** Which regions this video is available in. */\n    readonly regions: ReadonlyArray<Scalars['String']>;\n    /** The site that is streaming this media. */\n    readonly streamer: Streamer;\n    /** Languages this is translated to. Usually placed at bottom of media. */\n    readonly subs: ReadonlyArray<Scalars['String']>;\n    readonly updatedAt: Scalars['ISO8601DateTime'];\n    /** Fully qualified URL for the streaming link. */\n    readonly url: Scalars['String'];\n  };\n\n/** The connection type for StreamingLink. */\nexport type StreamingLinkConnection = {\n  readonly __typename?: 'StreamingLinkConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<StreamingLinkEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<StreamingLink>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type StreamingLinkEdge = {\n  readonly __typename?: 'StreamingLinkEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<StreamingLink>;\n};\n\nexport enum TitleLanguagePreferenceEnum {\n  /** Prefer the most commonly-used title for media */\n  Canonical = 'CANONICAL',\n  /** Prefer the romanized title for media */\n  Romanized = 'ROMANIZED',\n  /** Prefer the localized title for media */\n  Localized = 'LOCALIZED',\n}\n\nexport type TitlesList = {\n  readonly __typename?: 'TitlesList';\n  /** A list of additional, alternative, abbreviated, or unofficial titles */\n  readonly alternatives?: Maybe<ReadonlyArray<Scalars['String']>>;\n  /** The official or de facto international title */\n  readonly canonical?: Maybe<Scalars['String']>;\n  /** The locale code that identifies which title is used as the canonical title */\n  readonly canonicalLocale?: Maybe<Scalars['String']>;\n  /** The list of localized titles keyed by locale */\n  readonly localized: Scalars['Map'];\n};\n\nexport type TitlesListLocalizedArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\nexport type TitlesListInput = {\n  readonly localized?: Maybe<Scalars['Map']>;\n  readonly alternatives?: Maybe<ReadonlyArray<Scalars['String']>>;\n  readonly canonicalLocale?: Maybe<Scalars['String']>;\n};\n\n/** Media units such as episodes or chapters */\nexport type Unit = {\n  /** A brief summary or description of the unit */\n  readonly description: Scalars['Map'];\n  readonly id: Scalars['ID'];\n  /** The sequence number of this unit */\n  readonly number: Scalars['Int'];\n  /** A thumbnail image for the unit */\n  readonly thumbnail?: Maybe<Image>;\n  /** The titles for this unit in various locales */\n  readonly titles: TitlesList;\n};\n\n/** Media units such as episodes or chapters */\nexport type UnitDescriptionArgs = {\n  locales?: Maybe<ReadonlyArray<Scalars['String']>>;\n};\n\nexport type UnlockInput = {\n  readonly id: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnlockPost */\nexport type UnlockPostPayload = {\n  readonly __typename?: 'UnlockPostPayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly post?: Maybe<Post>;\n};\n\n/** Autogenerated return type of Unsubscribe */\nexport type UnsubscribePayload = {\n  readonly __typename?: 'UnsubscribePayload';\n  /** Graphql Errors */\n  readonly errors?: Maybe<ReadonlyArray<Generic>>;\n  readonly expiresAt?: Maybe<Scalars['ISO8601DateTime']>;\n};\n\n/** The media video. */\nexport type Video = Streamable &\n  WithTimestamps & {\n    readonly __typename?: 'Video';\n    readonly createdAt: Scalars['ISO8601DateTime'];\n    /** Spoken language is replaced by language of choice. */\n    readonly dubs: ReadonlyArray<Scalars['String']>;\n    /** The episode of this video */\n    readonly episode: Episode;\n    readonly id: Scalars['ID'];\n    /** Which regions this video is available in. */\n    readonly regions: ReadonlyArray<Scalars['String']>;\n    /** The site that is streaming this media. */\n    readonly streamer: Streamer;\n    /** Languages this is translated to. Usually placed at bottom of media. */\n    readonly subs: ReadonlyArray<Scalars['String']>;\n    readonly updatedAt: Scalars['ISO8601DateTime'];\n    /** The url of the video. */\n    readonly url: Scalars['String'];\n  };\n\n/** The connection type for Video. */\nexport type VideoConnection = {\n  readonly __typename?: 'VideoConnection';\n  /** A list of edges. */\n  readonly edges?: Maybe<ReadonlyArray<Maybe<VideoEdge>>>;\n  /** A list of nodes. */\n  readonly nodes?: Maybe<ReadonlyArray<Maybe<Video>>>;\n  /** Information to aid in pagination. */\n  readonly pageInfo: PageInfo;\n  /** The total amount of nodes. */\n  readonly totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type VideoEdge = {\n  readonly __typename?: 'VideoEdge';\n  /** A cursor for use in pagination. */\n  readonly cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  readonly node?: Maybe<Video>;\n};\n\n/** A manga volume which can contain multiple chapters. */\nexport type Volume = WithTimestamps & {\n  readonly __typename?: 'Volume';\n  /** The chapters in this volume. */\n  readonly chapters?: Maybe<ChapterConnection>;\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly id: Scalars['ID'];\n  /** The isbn number of this volume. */\n  readonly isbn: ReadonlyArray<Scalars['String']>;\n  /** The manga this volume is in. */\n  readonly manga: Manga;\n  /** The volume number. */\n  readonly number: Scalars['Int'];\n  /** The date when this chapter was released. */\n  readonly published?: Maybe<Scalars['ISO8601Date']>;\n  /** The titles for this chapter in various locales */\n  readonly titles: TitlesList;\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n\n/** A manga volume which can contain multiple chapters. */\nexport type VolumeChaptersArgs = {\n  after?: Maybe<Scalars['String']>;\n  before?: Maybe<Scalars['String']>;\n  first?: Maybe<Scalars['Int']>;\n  last?: Maybe<Scalars['Int']>;\n};\n\nexport type WithTimestamps = {\n  readonly createdAt: Scalars['ISO8601DateTime'];\n  readonly updatedAt: Scalars['ISO8601DateTime'];\n};\n","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\ui\\useDropdown.tsx",["114"],"import React, { ReactElement, useState } from 'react';\n\n// Styles\nimport { MediaSelector } from '../../styles/components/select';\n// Media\nimport { ReactComponent as CaretDownFill } from '../../assets/caretDownFill.svg';\n\nconst useDropdown = (\n  label: string,\n  defaultState: string,\n  options: Array<string>\n): [string, any, React.Dispatch<React.SetStateAction<string>>] => {\n  const [state, setState] = useState(defaultState);\n  const id = `use-dropdown-${label.replace(' ', '').toLowerCase()}`;\n\n  const Dropdown = (): ReactElement => (\n    <label htmlFor={id}>\n      {label}\n      <MediaSelector\n        id={id}\n        value={state}\n        onChange={(e) => setState(e.target.value)}\n        onBlur={(e) => setState(e.target.value)}\n        disabled={options.length === 0}>\n        {options.map((item) => (\n          <option key={item} value={item}>\n            {item.toLowerCase().replace(/^\\w/, (c) => c.toUpperCase())}\n          </option>\n        ))}\n      </MediaSelector>\n      <CaretDownFill />\n    </label>\n  );\n\n  return [state, Dropdown, setState];\n};\n\nexport default useDropdown;\n","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\routes\\Anime\\Edit.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\ui\\Spinner.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\components\\anime\\AnimeEdit.tsx",["115","116","117","118","119","120","121","122"],"import React, { ReactElement } from 'react';\nimport { FindAnimeFieldsFragment } from '../../routes/Anime/findAnimeById.types';\nimport EditProvider from '../ui/edit/EditProvider';\nimport InputField from '../ui/edit/InputField';\nimport SelectField from '../ui/edit/SelectField';\nimport ImageField from '../ui/edit/ImageField';\nimport TitlesField from '../ui/edit/TitlesField';\nimport MapField from '../ui/edit/MapField';\nimport FormActions from '../ui/edit/FormActions';\nimport { Maybe } from 'src/types/graphql';\n\nconst AnimeEdit = ({\n  anime,\n  onSave,\n}: {\n  anime: Maybe<FindAnimeFieldsFragment | undefined>;\n  onSave: any;\n}): ReactElement => {\n  return <div>Hello</div>;\n};\n// <form>\n// <EditProvider initialValue={anime}>\n//   <InputField readOnly field=\"id\" type=\"text\" />\n//   <InputField readOnly field=\"slug\" type=\"text\" />\n//   <TitlesField field=\"titles\" />\n//   <MapField field=\"synopsis\" keyName=\"Locale\" type=\"textarea\" />\n//   <ImageField field=\"posterImage\" type=\"image\" />\n//   <ImageField field=\"bannerImage\" type=\"image\" />\n//   <InputField\n//     field=\"sfw\"\n//     type=\"checkbox\"\n//     validate={() => ['error1', 'error2']}\n//   />\n//   <SelectField field=\"ageRating\" options={['G', 'PG', 'R', 'R18']} />\n//   <InputField field=\"ageRatingGuide\" type=\"text\" />\n//   <SelectField\n//     field=\"season\"\n//     options={['WINTER', 'SPRING', 'SUMMER', 'FALL']}\n//   />\n//   <SelectField\n//     field=\"status\"\n//     options={['TBA', 'FINISHED', 'CURRENT', 'UPCOMING', 'UNRELEASED']}\n//   />\n//   <InputField field=\"startDate\" type=\"date\" />\n//   <InputField field=\"endDate\" type=\"date\" />\n//   <InputField readOnly field=\"nextRelease\" type=\"datetime-local\" />\n//   <InputField field=\"episodeCount\" type=\"number\" />\n//   <InputField field=\"episodeLength\" type=\"number\" />\n//   <InputField readOnly field=\"totalLength\" type=\"text\" />\n//   <InputField readOnly field=\"userCount\" type=\"text\" />\n//   <InputField readOnly field=\"favoritesCount\" type=\"text\" />\n//   <InputField readOnly field=\"averageRating\" type=\"text\" />\n//   <FormActions onSave={onSave} />\n// </EditProvider>\n// </form>\n\nexport default AnimeEdit;\n","C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\globalStyles.tsx",[],["123","124"],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\GlobalStyles.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\searchMedia\\SearchMediaLayout.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\components\\button.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\components\\input.tsx",[],"C:\\Users\\peri2\\Documents\\GitHub\\kitsu-wiki\\src\\styles\\components\\select.tsx",[],{"ruleId":"125","replacedBy":"126"},{"ruleId":"127","replacedBy":"128"},{"ruleId":"129","severity":1,"message":"130","line":11,"column":8,"nodeType":"131","messageId":"132","endLine":11,"endColumn":33},{"ruleId":"129","severity":1,"message":"133","line":11,"column":26,"nodeType":"134","messageId":"135","endLine":11,"endColumn":32},{"ruleId":"129","severity":1,"message":"130","line":116,"column":8,"nodeType":"131","messageId":"132","endLine":116,"endColumn":29},{"ruleId":"125","replacedBy":"126"},{"ruleId":"127","replacedBy":"128"},{"ruleId":"136","severity":1,"message":"137","line":6,"column":3,"nodeType":"134","messageId":"138","endLine":6,"endColumn":7},{"ruleId":"136","severity":1,"message":"139","line":7,"column":3,"nodeType":"134","messageId":"138","endLine":7,"endColumn":22},{"ruleId":"129","severity":1,"message":"130","line":19,"column":13,"nodeType":"140","messageId":"132","endLine":19,"endColumn":18},{"ruleId":"136","severity":1,"message":"141","line":20,"column":10,"nodeType":"134","messageId":"138","endLine":20,"endColumn":22},{"ruleId":"136","severity":1,"message":"142","line":20,"column":24,"nodeType":"134","messageId":"138","endLine":20,"endColumn":39},{"ruleId":"136","severity":1,"message":"143","line":5,"column":27,"nodeType":"134","messageId":"138","endLine":5,"endColumn":45},{"ruleId":"136","severity":1,"message":"144","line":6,"column":28,"nodeType":"134","messageId":"138","endLine":6,"endColumn":47},{"ruleId":"136","severity":1,"message":"137","line":2,"column":10,"nodeType":"134","messageId":"138","endLine":2,"endColumn":14},{"ruleId":"136","severity":1,"message":"145","line":34,"column":27,"nodeType":"134","messageId":"138","endLine":34,"endColumn":31},{"ruleId":"146","severity":1,"message":"147","line":9,"column":10,"nodeType":"148","messageId":"149","endLine":9,"endColumn":13,"suggestions":"150"},{"ruleId":"146","severity":1,"message":"147","line":10,"column":13,"nodeType":"148","messageId":"149","endLine":10,"endColumn":16,"suggestions":"151"},{"ruleId":"146","severity":1,"message":"147","line":17,"column":9,"nodeType":"148","messageId":"149","endLine":17,"endColumn":12,"suggestions":"152"},{"ruleId":"146","severity":1,"message":"147","line":19,"column":16,"nodeType":"148","messageId":"149","endLine":19,"endColumn":19,"suggestions":"153"},{"ruleId":"146","severity":1,"message":"147","line":21,"column":20,"nodeType":"148","messageId":"149","endLine":21,"endColumn":23,"suggestions":"154"},{"ruleId":"146","severity":1,"message":"147","line":23,"column":8,"nodeType":"148","messageId":"149","endLine":23,"endColumn":11,"suggestions":"155"},{"ruleId":"146","severity":1,"message":"147","line":24,"column":11,"nodeType":"148","messageId":"149","endLine":24,"endColumn":14,"suggestions":"156"},{"ruleId":"146","severity":1,"message":"147","line":12,"column":13,"nodeType":"148","messageId":"149","endLine":12,"endColumn":16,"suggestions":"157"},{"ruleId":"136","severity":1,"message":"158","line":3,"column":8,"nodeType":"134","messageId":"138","endLine":3,"endColumn":20},{"ruleId":"136","severity":1,"message":"159","line":4,"column":8,"nodeType":"134","messageId":"138","endLine":4,"endColumn":18},{"ruleId":"136","severity":1,"message":"160","line":5,"column":8,"nodeType":"134","messageId":"138","endLine":5,"endColumn":19},{"ruleId":"136","severity":1,"message":"161","line":6,"column":8,"nodeType":"134","messageId":"138","endLine":6,"endColumn":18},{"ruleId":"136","severity":1,"message":"162","line":7,"column":8,"nodeType":"134","messageId":"138","endLine":7,"endColumn":19},{"ruleId":"136","severity":1,"message":"163","line":8,"column":8,"nodeType":"134","messageId":"138","endLine":8,"endColumn":16},{"ruleId":"136","severity":1,"message":"164","line":9,"column":8,"nodeType":"134","messageId":"138","endLine":9,"endColumn":19},{"ruleId":"146","severity":1,"message":"147","line":17,"column":11,"nodeType":"148","messageId":"149","endLine":17,"endColumn":14,"suggestions":"165"},{"ruleId":"125","replacedBy":"166"},{"ruleId":"127","replacedBy":"167"},"no-native-reassign",["168"],"no-negated-in-lhs",["169"],"@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","FunctionDeclaration","missingReturnType","Argument 'config' should be typed.","Identifier","missingArgType","@typescript-eslint/no-unused-vars","'Link' is defined but never used.","unusedVar","'RouteComponentProps' is defined but never used.","ArrowFunctionExpression","'dropdownOpen' is assigned a value but never used.","'setDropdownOpen' is assigned a value but never used.","'setAddDropdownOpen' is assigned a value but never used.","'setEditDropdownOpen' is assigned a value but never used.","'data' is assigned a value but never used.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["170","171"],["172","173"],["174","175"],["176","177"],["178","179"],["180","181"],["182","183"],["184","185"],"'EditProvider' is defined but never used.","'InputField' is defined but never used.","'SelectField' is defined but never used.","'ImageField' is defined but never used.","'TitlesField' is defined but never used.","'MapField' is defined but never used.","'FormActions' is defined but never used.",["186","187"],["168"],["169"],"no-global-assign","no-unsafe-negation",{"messageId":"188","fix":"189","desc":"190"},{"messageId":"191","fix":"192","desc":"193"},{"messageId":"188","fix":"194","desc":"190"},{"messageId":"191","fix":"195","desc":"193"},{"messageId":"188","fix":"196","desc":"190"},{"messageId":"191","fix":"197","desc":"193"},{"messageId":"188","fix":"198","desc":"190"},{"messageId":"191","fix":"199","desc":"193"},{"messageId":"188","fix":"200","desc":"190"},{"messageId":"191","fix":"201","desc":"193"},{"messageId":"188","fix":"202","desc":"190"},{"messageId":"191","fix":"203","desc":"193"},{"messageId":"188","fix":"204","desc":"190"},{"messageId":"191","fix":"205","desc":"193"},{"messageId":"188","fix":"206","desc":"190"},{"messageId":"191","fix":"207","desc":"193"},{"messageId":"188","fix":"208","desc":"190"},{"messageId":"191","fix":"209","desc":"193"},"suggestUnknown",{"range":"210","text":"211"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"210","text":"212"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"213","text":"211"},{"range":"213","text":"212"},{"range":"214","text":"211"},{"range":"214","text":"212"},{"range":"215","text":"211"},{"range":"215","text":"212"},{"range":"216","text":"211"},{"range":"216","text":"212"},{"range":"217","text":"211"},{"range":"217","text":"212"},{"range":"218","text":"211"},{"range":"218","text":"212"},{"range":"219","text":"211"},{"range":"219","text":"212"},{"range":"220","text":"211"},{"range":"220","text":"212"},[175,178],"unknown","never",[192,195],[554,557],[608,611],[670,673],[724,727],[739,742],[322,325],[621,624]]